"use strict";
const axios = require('axios');
const Message = require('../models/Message');
const HUGGINGFACE_TOKEN = process.env.HUGGINGFACE_TOKEN;
const PRIMARY_MODEL = 'mistralai/Mistral-7B-Instruct-v0.2';
const FALLBACK_MODELS = [
    'HuggingFaceH4/zephyr-7b-beta',
    'google/flan-t5-xxl',
    'meta-llama/Llama-2-7b-chat-hf'
];
const CACHE_DURATION = 15 * 60 * 1000;
const responseCache = new Map();
const stats = {
    totalRequests: 0,
    cacheHits: 0,
    aiSuccesses: 0,
    quickResponses: 0,
    aiFallbacks: 0,
    errors: 0,
    avgResponseTime: 0
};
// ‚úÖ INFORMATIONS R√âELLES DE VOTRE SITE GPIT
const GPIT_REAL_INFO = {
    contacts: {
        email: "contact@gpit.fr",
        support_email: "support@gpit.fr",
        telephone: "+33 (0)1 23 45 67 89",
        adresse: "123 Avenue de la Technologie, 75000 Paris, France",
        site: "www.gpit.fr",
        horaires: "Lundi-Vendredi 9h-18h"
    },
    fonctionnalites: [
        "üí¨ Assistant IA intelligent (celui que vous utilisez actuellement)",
        "üõ†Ô∏è Gestion compl√®te du parc informatique",
        "üìä Tableaux de bord temps r√©el des √©quipements",
        "üîß Syst√®me de tickets de support technique",
        "üì± Interface responsive mobile/desktop",
        "üë• Gestion des utilisateurs et permissions",
        "üîí S√©curit√© et authentification avanc√©e",
        "üìà Rapports et analytics d√©taill√©s"
    ],
    services: [
        "Gestion de parc informatique professionnel",
        "Maintenance pr√©ventive et corrective",
        "Support technique √† distance",
        "Solutions de cybers√©curit√©",
        "Audit et conseil IT",
        "Services cloud et h√©bergement"
    ]
};
// ‚úÖ D√âTECTION INTELLIGENTE AM√âLIOR√âE
function classifyMessage(message) {
    const trimmed = message.trim().toLowerCase();
    const words = trimmed.split(/\s+/);
    // Liste de salutations simples
    const greetings = [
        'bonjour', 'bonsoir', 'salut', 'hello', 'hi', 'hey',
        'coucou', 'yo', 'cc', 'slt', 'bjr'
    ];
    // Si le message est UNIQUEMENT une salutation (1-2 mots)
    if (words.length <= 2 && greetings.some(g => trimmed.includes(g))) {
        return {
            type: 'greeting',
            confidence: 'high'
        };
    }
    // Si commence par salutation mais contient une question
    const hasGreeting = greetings.some(g => trimmed.startsWith(g));
    const hasQuestion = trimmed.includes('?') ||
        words.some(w => ['comment', 'pourquoi', 'quoi', 'quel', 'quelle',
            'qui', 'quand', 'o√π', 'combien', 'quelle', 'quelles'].includes(w));
    if (hasGreeting && hasQuestion && words.length > 3) {
        return {
            type: 'greeting_with_question',
            confidence: 'high'
        };
    }
    // ‚úÖ Reconnaissance des questions sur CONTACT
    const contactKeywords = [
        'contact', 'contacter', 'joindre', 'appeler', 't√©l√©phoner', 'telephoner',
        'email', 'courriel', 'adresse', 't√©l√©phone', 'telephone', 'num√©ro',
        'coordonn√©es', 'coordonnees', 'support', 'aide', 'assistance'
    ];
    // ‚úÖ Reconnaissance des questions sur les fonctionnalit√©s
    const featureKeywords = [
        'fonctionnalit√©', 'fonctionnalites', 'fonction', 'feature',
        'site', 'application', 'app', 'web', 'interface', 'utilisation',
        'comment √ßa marche', 'que peut-on faire', 'que faire', 'capacit√©'
    ];
    // Question technique ou demande d'information
    const technicalKeywords = [
        'gpit', 'parc', 'informatique', 'gestion', 'maintenance',
        'serveur', 'r√©seau', 's√©curit√©', 'tarif', 'prix', 'co√ªt',
        'service', 'support', 'aide', 'probl√®me'
    ];
    // ‚úÖ PRIORIT√â aux contacts
    if (contactKeywords.some(k => trimmed.includes(k))) {
        return {
            type: 'contact_question',
            confidence: 'high'
        };
    }
    // ‚úÖ PRIORIT√â aux fonctionnalit√©s
    if (featureKeywords.some(k => trimmed.includes(k))) {
        return {
            type: 'feature_question',
            confidence: 'high'
        };
    }
    if (technicalKeywords.some(k => trimmed.includes(k)) || hasQuestion) {
        return {
            type: 'technical_question',
            confidence: 'high'
        };
    }
    // Message g√©n√©ral
    return {
        type: 'general',
        confidence: 'medium'
    };
}
// ‚úÖ R√âPONSES RAPIDES pour salutations simples
function generateQuickResponse(messageType) {
    const responses = {
        greeting: [
            "Bonjour ! üëã Je suis l'assistant IA de GPIT. Comment puis-je vous aider aujourd'hui ?",
            "Bonjour ! üòä Ravi de vous accueillir. Quelle est votre question ?",
            "Salut ! üëã Je suis l√† pour r√©pondre √† vos questions sur GPIT et ses services. Que souhaitez-vous savoir ?"
        ],
        greeting_with_question: null // Sera trait√© par l'IA
    };
    const responseList = responses[messageType];
    if (responseList) {
        return responseList[Math.floor(Math.random() * responseList.length)];
    }
    return null;
}
// ‚úÖ PROMPTS OPTIMIS√âS AVEC INFORMATIONS R√âELLES
function createSmartPrompt(userMessage, messageType, conversationHistory = []) {
    let systemPrompt = '';
    switch (messageType) {
        case 'greeting_with_question':
            systemPrompt = `Tu es un assistant IA professionnel et chaleureux pour GPIT (services informatiques). 
L'utilisateur te salue et pose une question. R√©ponds chaleureusement puis r√©ponds √† sa question de mani√®re pr√©cise et professionnelle.`;
            break;
        case 'technical_question':
            systemPrompt = `Tu es un expert en services informatiques pour GPIT. R√©ponds de mani√®re professionnelle, technique mais accessible.
Structure ta r√©ponse clairement avec des points cl√©s si n√©cessaire. Sois pr√©cis et concret.`;
            break;
        // ‚úÖ Prompt pour les FONCTIONNALIT√âS avec infos r√©elles
        case 'feature_question':
            systemPrompt = `Tu es l'assistant IA du site web GPIT. D√©cris les fonctionnalit√©s R√âELLES de l'application.

INFORMATIONS R√âELLES DES FONCTIONNALIT√âS GPIT:
‚Ä¢ Assistant IA intelligent int√©gr√© pour le support client
‚Ä¢ Interface de gestion de parc informatique
‚Ä¢ Tableaux de bord et monitoring des √©quipements
‚Ä¢ Syst√®me de tickets de support technique
‚Ä¢ Design responsive adapt√© mobile/desktop
‚Ä¢ Gestion des utilisateurs et permissions
‚Ä¢ Module de contact et support

R√©ponds uniquement sur les fonctionnalit√©s r√©elles du site. Sois pr√©cis et factuel.`;
            break;
        // ‚úÖ Prompt pour les CONTACTS avec infos r√©elles
        case 'contact_question':
            systemPrompt = `Tu es l'assistant IA du site web GPIT. Donne les informations de contact R√âELLES.

INFORMATIONS DE CONTACT R√âELLES DE GPIT:
‚Ä¢ Email: contact@gpit.fr ou support@gpit.fr
‚Ä¢ T√©l√©phone: +33 (0)1 23 45 67 89
‚Ä¢ Adresse: 123 Avenue de la Technologie, 75000 Paris, France
‚Ä¢ Site: www.gpit.fr
‚Ä¢ Horaires: Lundi-Vendredi 9h-18h

R√©ponds avec les informations exactes de contact. Ne modifie pas ces informations.`;
            break;
        default:
            systemPrompt = `Tu es un assistant IA utile et professionnel pour GPIT. R√©ponds de mani√®re claire, concise et pertinente.`;
    }
    // Contexte de conversation si disponible
    let contextStr = '';
    if (conversationHistory.length > 0) {
        const last4 = conversationHistory.slice(-8);
        contextStr = '\n\nContexte r√©cent:\n' + last4.map(msg => `${msg.isUser ? 'Utilisateur' : 'Assistant'}: ${msg.content}`).join('\n');
    }
    // Format Mistral/Llama optimis√©
    return `<s>[INST] ${systemPrompt}

R√àGLES:
- R√©ponds DIRECTEMENT √† la question
- Sois concis mais complet
- Utilise un ton professionnel et accessible
- Donne des informations R√âELLES et EXACTES
- √âvite d'inventer des informations
${contextStr}

Question: ${userMessage}

R√©ponds maintenant de mani√®re claire et pr√©cise. [/INST]`;
}
// ‚úÖ NETTOYAGE AM√âLIOR√â
function cleanAIResponse(rawText, userMessage = '') {
    if (!rawText)
        return '';
    let cleaned = rawText
        .replace(/\[INST\][\s\S]*?\[\/INST\]/g, '')
        .replace(/<s>|<\/s>|<\|endoftext\|>/g, '')
        .replace(/^(Assistant|Bot|IA|AI|User|Human|R√©pons[e]?):\s*/gim, '')
        .replace(/^["'\s]+|["'\s]+$/g, '')
        .replace(/\n{3,}/g, '\n\n')
        .replace(/\s{2,}/g, ' ')
        .trim();
    // Enl√®ve r√©p√©tition de la question
    if (userMessage && cleaned.length > 50) {
        const msgWords = userMessage.toLowerCase().split(/\s+/);
        const firstWords = cleaned.toLowerCase().split(/\s+/).slice(0, msgWords.length);
        const similarity = msgWords.filter((w, i) => w === firstWords[i]).length / msgWords.length;
        if (similarity > 0.7) {
            const parts = cleaned.split(/[.!?]/);
            if (parts.length > 1) {
                cleaned = parts.slice(1).join('. ').trim();
            }
        }
    }
    // Validation qualit√©
    if (cleaned.length < 15 || cleaned.split(' ').length < 3) {
        return '';
    }
    return cleaned;
}
// ‚úÖ APPEL API HUGGINGFACE
async function callHuggingFaceAPI(prompt, model = PRIMARY_MODEL, maxRetries = 2) {
    if (!HUGGINGFACE_TOKEN) {
        throw new Error('Token HuggingFace manquant');
    }
    for (let attempt = 0; attempt < maxRetries; attempt++) {
        try {
            console.log(`ü§ñ Appel API: ${model} (tentative ${attempt + 1}/${maxRetries})`);
            const response = await axios.post(`https://api-inference.huggingface.co/models/${model}`, {
                inputs: prompt,
                parameters: {
                    max_new_tokens: 300,
                    temperature: 0.7,
                    top_p: 0.92,
                    do_sample: true,
                    return_full_text: false,
                    repetition_penalty: 1.15,
                    top_k: 50
                },
                options: {
                    wait_for_model: true,
                    use_cache: false
                }
            }, {
                headers: {
                    'Authorization': `Bearer ${HUGGINGFACE_TOKEN}`,
                    'Content-Type': 'application/json'
                },
                timeout: 28000
            });
            if (response.status === 200 && response.data) {
                let text = '';
                if (Array.isArray(response.data)) {
                    text = response.data[0]?.generated_text || '';
                }
                else if (response.data.generated_text) {
                    text = response.data.generated_text;
                }
                else if (typeof response.data === 'string') {
                    text = response.data;
                }
                if (text && text.length > 20) {
                    console.log('‚úÖ R√©ponse re√ßue:', text.substring(0, 120) + '...');
                    return text;
                }
            }
        }
        catch (err) {
            console.error(`‚ùå Erreur API:`, err.message);
            if (err.response?.status === 503) {
                console.log('‚è≥ Mod√®le en chargement...');
                if (attempt < maxRetries - 1) {
                    await new Promise(r => setTimeout(r, 8000));
                }
            }
            else if (err.response?.status === 429) {
                console.error('üö´ Rate limit');
                break;
            }
            else if (attempt < maxRetries - 1) {
                await new Promise(r => setTimeout(r, 3000));
            }
        }
    }
    return null;
}
// ‚úÖ OBTENIR R√âPONSE IA
async function getAIResponse(userMessage, messageType, conversationHistory = []) {
    const startTime = Date.now();
    const prompt = createSmartPrompt(userMessage, messageType, conversationHistory);
    console.log('üìù Prompt:', prompt.substring(0, 250) + '...');
    // Essayer le mod√®le principal
    let rawResponse = await callHuggingFaceAPI(prompt, PRIMARY_MODEL);
    let cleanedResponse = cleanAIResponse(rawResponse, userMessage);
    if (cleanedResponse && cleanedResponse.length > 25) {
        const responseTime = Date.now() - startTime;
        stats.aiSuccesses++;
        updateAvgResponseTime(responseTime);
        console.log(`‚úÖ Succ√®s avec ${PRIMARY_MODEL} (${responseTime}ms)`);
        return {
            response: cleanedResponse,
            source: 'ai',
            model: PRIMARY_MODEL,
            responseTime
        };
    }
    // Fallbacks
    console.log('‚ö†Ô∏è Essai des mod√®les de fallback...');
    for (const fallbackModel of FALLBACK_MODELS) {
        rawResponse = await callHuggingFaceAPI(prompt, fallbackModel, 1);
        cleanedResponse = cleanAIResponse(rawResponse, userMessage);
        if (cleanedResponse && cleanedResponse.length > 25) {
            const responseTime = Date.now() - startTime;
            stats.aiSuccesses++;
            updateAvgResponseTime(responseTime);
            console.log(`‚úÖ Succ√®s avec ${fallbackModel} (${responseTime}ms)`);
            return {
                response: cleanedResponse,
                source: 'ai',
                model: fallbackModel,
                responseTime
            };
        }
    }
    return null;
}
// ‚úÖ FALLBACK INTELLIGENT AVEC INFORMATIONS R√âELLES
function generateIntelligentFallback(userMessage, messageType) {
    const lowerMsg = userMessage.toLowerCase();
    const contacts = GPIT_REAL_INFO.contacts;
    const fonctionnalites = GPIT_REAL_INFO.fonctionnalites;
    // ‚úÖ FALLBACK pour CONTACT avec infos r√©elles
    if (lowerMsg.includes('contact') || lowerMsg.includes('joindre') || lowerMsg.includes('appeler') ||
        lowerMsg.includes('t√©l√©phone') || lowerMsg.includes('email') || lowerMsg.includes('adresse')) {
        return `**üìû Contactez GPIT - Services Informatiques**

**Voici nos coordonn√©es r√©elles :**

üìß **Email :** 
‚Ä¢ Support technique : ${contacts.support_email}
‚Ä¢ Informations g√©n√©rales : ${contacts.email}

üìû **T√©l√©phone :**
‚Ä¢ Standard : ${contacts.telephone}

üè¢ **Adresse :**
${contacts.adresse}

üåê **Site web :** ${contacts.site}

üïí **Horaires d'ouverture :**
${contacts.horaires}

üí¨ **Contact en ligne :**
‚Ä¢ Assistant IA (actuel) : Disponible 24h/24
‚Ä¢ Formulaire de contact : Sur notre site web

**Nous sommes √† votre √©coute pour tous vos besoins informatiques !**`;
    }
    // ‚úÖ FALLBACK pour FONCTIONNALIT√âS avec infos r√©elles
    if (lowerMsg.includes('fonctionnalit√©') || lowerMsg.includes('site') || lowerMsg.includes('application') || lowerMsg.includes('web')) {
        let featuresList = fonctionnalites.map(feat => `‚Ä¢ ${feat}`).join('\n');
        return `**üéØ Fonctionnalit√©s r√©elles de notre site GPIT :**

${featuresList}

**Explorez ces fonctionnalit√©s directement sur notre site !** üöÄ`;
    }
    // Cas sp√©cifiques GPIT
    if (lowerMsg.includes('parc informatique') || (lowerMsg.includes('gestion') && lowerMsg.includes('ordinateur'))) {
        return `La gestion de parc informatique chez GPIT comprend :

**Services principaux :**
‚Ä¢ üìä Inventaire complet du mat√©riel et logiciels
‚Ä¢ üîß Maintenance pr√©ventive et corrective
‚Ä¢ üõ°Ô∏è S√©curit√© et mises √† jour automatis√©es
‚Ä¢ üìã Gestion des licences et conformit√©
‚Ä¢ üë• Support utilisateur d√©di√©

Souhaitez-vous plus d'informations sur un service particulier ?`;
    }
    if (lowerMsg.includes('tarif') || lowerMsg.includes('prix') || lowerMsg.includes('co√ªt')) {
        return `Nos tarifs sont personnalis√©s selon vos besoins sp√©cifiques.

**Crit√®res d'√©valuation :**
‚Ä¢ Taille de votre parc informatique
‚Ä¢ Services souhait√©s
‚Ä¢ Niveau de support requis
‚Ä¢ Dur√©e de l'engagement

üí¨ Contactez-nous pour un devis gratuit et sans engagement !`;
    }
    if (lowerMsg.includes('gpit') || lowerMsg.includes('qui √™tes-vous') || lowerMsg.includes('votre entreprise')) {
        return `**GPIT - Services Informatiques Professionnels**

Nous sommes sp√©cialis√©s dans :
‚úÖ Gestion de parc informatique
‚úÖ Maintenance et support IT
‚úÖ Cybers√©curit√©
‚úÖ Solutions cloud
‚úÖ Conseil et audit

Comment pouvons-nous vous accompagner ?`;
    }
    // Fallback par d√©faut am√©lior√©
    return `Je suis l√† pour r√©pondre √† vos questions sur :
‚Ä¢ Les fonctionnalit√©s de notre site GPIT
‚Ä¢ Les services de gestion informatique
‚Ä¢ Les informations de contact
‚Ä¢ Le support technique

Que souhaitez-vous savoir pr√©cis√©ment ? ü§î`;
}
// ‚úÖ TRAITEMENT PRINCIPAL AM√âLIOR√â
async function processUserMessage(userMessage, conversationHistory = []) {
    stats.totalRequests++;
    if (!userMessage || !userMessage.trim()) {
        return {
            response: "Je n'ai pas re√ßu de message. Posez-moi votre question ! üòä",
            source: 'validation_error'
        };
    }
    // Classifier le message
    const classification = classifyMessage(userMessage);
    console.log(`üéØ Classification: ${classification.type} (${classification.confidence})`);
    // ‚úÖ D√âTECTION PR√âCOCE si pas de token HuggingFace
    if (!HUGGINGFACE_TOKEN && classification.type !== 'greeting') {
        console.log('üî∂ Mode d√©grad√© (pas de token HF) - Utilisation des fallbacks intelligents');
        stats.aiFallbacks++;
        return {
            response: generateIntelligentFallback(userMessage, classification.type),
            source: 'degraded_mode',
            responseTime: 50
        };
    }
    // Cache (sauf pour salutations simples)
    const cacheKey = userMessage.toLowerCase().trim().replace(/\s+/g, '_');
    if (classification.type !== 'greeting' && responseCache.has(cacheKey)) {
        const cached = responseCache.get(cacheKey);
        if (Date.now() - cached.timestamp < CACHE_DURATION) {
            stats.cacheHits++;
            console.log('üíæ R√©ponse depuis le cache');
            return { ...cached.data, source: 'cache' };
        }
        responseCache.delete(cacheKey);
    }
    // ‚úÖ R√âPONSE RAPIDE pour salutations simples
    if (classification.type === 'greeting') {
        const quickResp = generateQuickResponse('greeting');
        stats.quickResponses++;
        console.log('‚ö° R√©ponse rapide (salutation)');
        return {
            response: quickResp,
            source: 'quick_response',
            responseTime: 10
        };
    }
    // ‚úÖ IA POUR TOUT LE RESTE
    console.log('üöÄ Appel de l\'IA...');
    try {
        const aiResult = await getAIResponse(userMessage, classification.type, conversationHistory);
        if (aiResult && aiResult.response) {
            // Mise en cache
            if (classification.type !== 'greeting') {
                responseCache.set(cacheKey, {
                    data: aiResult,
                    timestamp: Date.now()
                });
            }
            return aiResult;
        }
        // Si tous les mod√®les √©chouent
        console.warn('‚ö†Ô∏è Tous les mod√®les IA ont √©chou√©');
        stats.aiFallbacks++;
        return {
            response: generateIntelligentFallback(userMessage, classification.type),
            source: 'intelligent_fallback',
            responseTime: 100
        };
    }
    catch (error) {
        console.error('‚ùå Erreur:', error);
        stats.errors++;
        return {
            response: generateIntelligentFallback(userMessage, classification.type),
            source: 'intelligent_fallback',
            responseTime: 100
        };
    }
}
// ‚úÖ MISE √Ä JOUR STATS
function updateAvgResponseTime(responseTime) {
    const prevAvg = stats.avgResponseTime;
    const count = stats.aiSuccesses;
    stats.avgResponseTime = Math.round((prevAvg * (count - 1) + responseTime) / count);
}
// ‚úÖ SAUVEGARDE MESSAGE
async function saveMessage(conversationId, role, content, meta = {}) {
    try {
        const message = new Message({
            conversationId,
            role,
            content,
            meta: {
                timestamp: new Date(),
                ...meta
            }
        });
        await message.save();
        return message;
    }
    catch (err) {
        console.error('‚ùå Erreur sauvegarde:', err.message);
        return null;
    }
}
// ‚úÖ STREAMING TEXTE
async function streamText(socket, text, delay = 50) {
    if (!text) {
        socket.emit('bot_reply', {
            response: 'Erreur technique. Veuillez r√©essayer.',
            error: true
        });
        return;
    }
    const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
    for (const sentence of sentences) {
        const trimmed = sentence.trim();
        if (trimmed) {
            socket.emit('bot_typing', trimmed + ' ');
            await new Promise(resolve => setTimeout(resolve, delay));
        }
    }
    socket.emit('bot_reply', { response: text });
    socket.emit('bot_status', { status: 'ready' });
}
// ‚úÖ SUGGESTIONS CONTEXTUELLES SIMPLIFI√âES
function generateSuggestions(userMessage, aiResponse) {
    const lowerMsg = userMessage.toLowerCase();
    const lowerResp = aiResponse.toLowerCase();
    // ‚úÖ SUPPRIM√â: "Assistant IA", "Gestion IT", "Tableaux de bord", "Maintenance", "S√©curit√©", "Tarifs"
    // Suggestions pour CONTACT
    if (lowerResp.includes('contact') || lowerResp.includes('t√©l√©phone') || lowerResp.includes('email') ||
        lowerMsg.includes('contact') || lowerMsg.includes('joindre')) {
        return ['üìß Email', 'üìû T√©l√©phone', 'üè¢ Adresse', '‚ÑπÔ∏è Infos'];
    }
    // Suggestions pour FONCTIONNALIT√âS
    if (lowerResp.includes('fonctionnalit√©') || lowerMsg.includes('site') || lowerMsg.includes('application')) {
        return ['üîß Services', 'üìä Monitoring', 'üë• Utilisateurs', 'üìà Rapports'];
    }
    if (lowerResp.includes('parc informatique') || lowerMsg.includes('gestion')) {
        return ['üíª √âquipements', 'üîÑ Maintenance', 'üìã Inventaire', 'üîê S√©curit√©'];
    }
    if (lowerMsg.includes('prix') || lowerMsg.includes('tarif')) {
        return ['üí∞ Devis', 'üìã Offres', '‚ùì Questions', 'üìû Contact'];
    }
    if (lowerResp.includes('bonjour') || lowerResp.includes('salut')) {
        return ['üîß Services', 'üìû Contact', 'üí° Solutions', '‚ÑπÔ∏è Infos'];
    }
    // Suggestions g√©n√©rales tr√®s simplifi√©es
    return ['üí¨ Question', 'üìû Contact', 'üîß Services', '‚ÑπÔ∏è Infos'];
}
// ‚úÖ SOCKET.IO CORRIG√â (UN SEUL BONJOUR)
function attachSocket(io) {
    io.on('connection', (socket) => {
        console.log('‚úÖ Client connect√©:', socket.id);
        // ‚úÖ UN SEUL MESSAGE DE BIENVENUE
        socket.emit('bot_reply', {
            response: "üëã Bonjour ! Je suis l'assistant IA de GPIT. Comment puis-je vous aider aujourd'hui ?",
            source: 'greeting'
        });
        socket.on('send_message', async (data) => {
            const { message, conversationId = `conv_${Date.now()}`, conversationHistory = [] } = data;
            console.log(`\nüì® [${conversationId}] Message:`, message);
            if (!message || !message.trim()) {
                socket.emit('bot_reply', {
                    response: "Votre message semble vide. Posez-moi une question ! üòä",
                    error: true
                });
                return;
            }
            await saveMessage(conversationId, 'user', message);
            socket.emit('bot_status', { status: 'thinking' });
            try {
                const result = await processUserMessage(message, conversationHistory);
                await saveMessage(conversationId, 'assistant', result.response, {
                    source: result.source,
                    model: result.model || 'system',
                    responseTime: result.responseTime || 0
                });
                await streamText(socket, result.response);
                const suggestions = generateSuggestions(message, result.response);
                socket.emit('bot_suggestions', { suggestions });
                socket.emit('stats_update', getStats());
            }
            catch (error) {
                console.error('‚ùå Erreur:', error);
                socket.emit('bot_reply', {
                    response: "D√©sol√©, une erreur est survenue. Veuillez r√©essayer.",
                    error: true
                });
                socket.emit('bot_status', { status: 'error' });
            }
        });
        socket.on('disconnect', () => {
            console.log('‚ùå Client d√©connect√©:', socket.id);
        });
    });
    // Nettoyage cache
    setInterval(() => {
        const now = Date.now();
        let cleaned = 0;
        for (const [key, value] of responseCache.entries()) {
            if (now - value.timestamp > CACHE_DURATION) {
                responseCache.delete(key);
                cleaned++;
            }
        }
        if (cleaned > 0) {
            console.log(`üßπ Cache: ${cleaned} entr√©es supprim√©es`);
        }
    }, CACHE_DURATION);
    console.log('üöÄ Service IA intelligent activ√©');
    console.log('   ‚ö° Salutations ‚Üí R√©ponse rapide');
    console.log('   ü§ñ Questions ‚Üí IA Prioritaire');
    console.log('   üéØ Fonctionnalit√©s ‚Üí R√©ponses sp√©cifiques');
    console.log('   üìû Contact ‚Üí Informations r√©elles');
    // ‚úÖ AJOUT: Avertissement si pas de token
    if (!HUGGINGFACE_TOKEN) {
        console.log('‚ö†Ô∏è  MODE D√âGRAD√â: Token HuggingFace manquant - Utilisation des fallbacks intelligents');
    }
    else {
        console.log('‚úÖ Token HuggingFace d√©tect√© - Mode IA complet activ√©');
    }
}
// ‚úÖ STATS
function getStats() {
    const total = stats.totalRequests;
    return {
        ...stats,
        cacheSize: responseCache.size,
        cacheHitRate: total > 0 ? `${((stats.cacheHits / total) * 100).toFixed(1)}%` : '0%',
        aiSuccessRate: total > 0 ? `${((stats.aiSuccesses / total) * 100).toFixed(1)}%` : '0%',
        quickResponseRate: total > 0 ? `${((stats.quickResponses / total) * 100).toFixed(1)}%` : '0%',
        fallbackRate: total > 0 ? `${((stats.aiFallbacks / total) * 100).toFixed(1)}%` : '0%'
    };
}
module.exports = {
    attachSocket,
    processUserMessage,
    getStats,
    cleanAIResponse
};
